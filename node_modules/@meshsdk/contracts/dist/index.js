// src/common.ts
import { v2ScriptToBech32 } from "@meshsdk/core-csl";
var MeshTxInitiator = class {
  mesh;
  fetcher;
  wallet;
  stakeCredential;
  networkId = 0;
  constructor({
    mesh,
    fetcher,
    wallet,
    networkId,
    stakeCredential
  }) {
    this.mesh = mesh;
    if (fetcher) {
      this.fetcher = fetcher;
    }
    if (wallet) {
      this.wallet = wallet;
    }
    if (networkId) {
      this.networkId = networkId;
    }
    if (stakeCredential) {
      this.stakeCredential = this.stakeCredential;
    }
  }
  signSubmitReset = async () => {
    const signedTx = this.mesh.completeSigning();
    const txHash = await this.mesh.submitTx(signedTx);
    this.mesh.meshTxBuilderBody = this.mesh.emptyTxBuilderBody();
    return txHash;
  };
  queryUtxos = async (walletAddress) => {
    if (this.fetcher) {
      const utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);
      return utxos;
    }
    return [];
  };
  getWalletDappAddress = async () => {
    if (this.wallet) {
      const usedAddresses = await this.wallet.getUsedAddresses();
      if (usedAddresses.length > 0) {
        return usedAddresses[0];
      }
      const unusedAddresses = await this.wallet.getUnusedAddresses();
      if (unusedAddresses.length > 0) {
        return unusedAddresses[0];
      }
    }
    return "";
  };
  getWalletCollateral = async () => {
    if (this.wallet) {
      const utxos = await this.wallet.getCollateral();
      return utxos[0];
    }
    return void 0;
  };
  getWalletUtxosWithMinLovelace = async (lovelace, providedUtxos = []) => {
    let utxos = providedUtxos;
    if (this.wallet && (!providedUtxos || providedUtxos.length === 0)) {
      utxos = await this.wallet.getUtxos();
    }
    return utxos.filter((u) => {
      const lovelaceAmount = u.output.amount.find(
        (a) => a.unit === "lovelace"
      )?.quantity;
      return Number(lovelaceAmount) > lovelace;
    });
  };
  getWalletUtxosWithToken = async (assetHex, userUtxos = []) => {
    let utxos = userUtxos;
    if (this.wallet && userUtxos.length === 0) {
      utxos = await this.wallet.getUtxos();
    }
    return utxos.filter((u) => {
      const assetAmount = u.output.amount.find(
        (a) => a.unit === assetHex
      )?.quantity;
      return Number(assetAmount) >= 1;
    });
  };
  getAddressUtxosWithMinLovelace = async (walletAddress, lovelace, providedUtxos = []) => {
    let utxos = providedUtxos;
    if (this.fetcher && (!providedUtxos || providedUtxos.length === 0)) {
      utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);
    }
    return utxos.filter((u) => {
      const lovelaceAmount = u.output.amount.find(
        (a) => a.unit === "lovelace"
      )?.quantity;
      return Number(lovelaceAmount) > lovelace;
    });
  };
  getAddressUtxosWithToken = async (walletAddress, assetHex, userUtxos = []) => {
    let utxos = userUtxos;
    if (this.fetcher && userUtxos.length === 0) {
      utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);
    }
    return utxos.filter((u) => {
      const assetAmount = u.output.amount.find(
        (a) => a.unit === assetHex
      )?.quantity;
      return Number(assetAmount) >= 1;
    });
  };
  getWalletInfoForTx = async () => {
    const utxos = await this.wallet?.getUtxos();
    const collateral = await this.getWalletCollateral();
    const walletAddress = await this.getWalletDappAddress();
    if (!utxos || utxos?.length === 0) {
      throw new Error("No utxos found");
    }
    if (!collateral) {
      throw new Error("No collateral found");
    }
    if (!walletAddress) {
      throw new Error("No wallet address found");
    }
    return { utxos, collateral, walletAddress };
  };
  _getUtxoByTxHash = async (scriptCbor, txHash) => {
    if (this.fetcher) {
      const scriptAddr = v2ScriptToBech32(
        scriptCbor,
        void 0,
        this.networkId
      );
      const utxos = await this.fetcher.fetchAddressUTxOs(scriptAddr);
      return utxos.filter((utxo) => utxo.input.txHash === txHash)[0];
    }
    return void 0;
  };
};

// src/marketplace/offchain.ts
import {
  serializeBech32Address,
  v2ScriptToBech32 as v2ScriptToBech322,
  parseDatumCbor,
  parsePlutusAddressObjToBech32,
  applyParamsToScript
} from "@meshsdk/core-csl";
import {
  conStr0,
  pubKeyAddress,
  currencySymbol,
  tokenName,
  integer,
  mConStr1,
  mConStr0
} from "@meshsdk/common";

// src/marketplace/aiken-workspace/plutus.json
var plutus_default = {
  preamble: {
    title: "meshjs/marketplace",
    description: "Aiken contracts for project 'meshjs/marketplace'",
    version: "0.0.0",
    plutusVersion: "v2",
    compiler: {
      name: "Aiken",
      version: "v1.0.24-alpha+982eff4"
    },
    license: "Apache-2.0"
  },
  validators: [
    {
      title: "marketplace.marketplace",
      datum: {
        title: "datum",
        schema: {
          $ref: "#/definitions/marketplace~1types~1MarketplaceDatum"
        }
      },
      redeemer: {
        title: "redeemer",
        schema: {
          $ref: "#/definitions/marketplace~1types~1MarketplaceRedeemer"
        }
      },
      parameters: [
        {
          title: "owner",
          schema: {
            $ref: "#/definitions/aiken~1transaction~1credential~1Address"
          }
        },
        {
          title: "fee_percentage_basis_point",
          schema: {
            $ref: "#/definitions/Int"
          }
        }
      ],
      compiledCode: "59084201000032323232323232323222322223232533300b3232323232323232323253330153370e90010008991919299980c19b87480000044c94ccc064cdc3a400060300022646464646464a66603ea66603e00620022940400852819806998079bac300e301c3011301c01601b300c3370666e08dd69808180e00c00ca41413802660186601c6eb0c034c06cc040c06c054c040c06c05cc02ccdc01bad300f301b0173330113756601e6036601e60360069110048810032533302000114a0264a666042002294452818118009919198008008011129998110008a5eb804c8c94ccc084cdd7980a180f9809980f80100309981280119802002000899802002000981300118120009bac300f301a300f301a014300e3019300d3019001301f00130170011632323300100100222533301e00114c103d87a800013232533301d3375e6020603600400e266e952000330210024bd70099802002000981100118100009bac300b3016300b301601013322323300100100322533301f00114a026464a66603c66e3c00801452889980200200098118011bae30210013758603a603c603c603c603c603c603c603c603c602c6016602c0206464a66603466e1d200030190011375c603e60300022c6018602e0026016602c024602c020603600260260042940c04c004c014c04402c94ccc04ccdc3800a4000297adef6c6013232330010014bd6f7b63011299980c80089980d19bb04c1014000374c00697adef6c60132323232533301a3375e6601e911000024c103d879800013301e33760981014000374c00e00a2a66603466e3d2210000213301e337609801014000374c00e00626603c66ec0dd48011ba600133006006003375660360066eb8c064008c074008c06c004c8cc0040052f5bded8c044a66603000226603266ec13001014000375000697adef6c6013232323253330193375e6601c911000024c103d879800013301d33760981014000375000e00a2a66603266e3d2210000213301d337609801014000375000e00626603a66ec0dd48011ba800133006006003375a60340066eb8c060008c070008c06800488c8c8cc004004008894ccc06400452889919299980c19b89375a601000466601800e6eb8c02c008dd718050010998020020008a50301d00237586036002646600200200444a666030002297ae0132333222323300100100322533301e001100313233020374e660406ea4018cc080dd49bae301d0013302037506eb4c0780052f5c066006006604400460400026eb8c05c004dd5980c00099801801980e001180d0009180b180b980b80091191980080080191299980b0008a5eb7bdb1804cc894ccc054cdd79804180980100289919199800800801801111299980e001080089919980200218100019991191980080080291299981080089981119bb037520086e9800d2f5bded8c0264646464a66604466ebccc05c020009300103d8798000133026337606ea4020dd30038028a99981119b8f0080021323253330243370e900000089981419bb037520146052604400400a200a604400264a666046a66604c00229445280a60103d87a800013374a9000198139ba60014bd70191998008008040011112999814001080089919980200218160019991191980080080291299981680089981719bb037520086ea000d2f5bded8c0264646464a66605c66ebccc08c020009300103d8798000133032337606ea4020dd40038028a99981719b8f0080021323253330303370e900000089981a19bb03752014606a605c00400a200a605c00264a66605e66e1c005200014c103d87a800013374a9000198199ba80014bd7019b80007001133032337606ea4008dd4000998030030019bad302f003375c605a0046062004605e0026eb8c09c004dd69814000981500109981319bb037520046e98004cc01801800cdd598118019bae302100230250023023001375c60360026eacc070004c078008dd5980398098010800980c00099801001180c8009180a180a80091809800911191919299980919b8748008004520001375a602e6020004602000264a66602266e1d200200114c0103d87a8000132323300100100222533301700114c103d87a800013232323253330183371e014004266e9520003301c375000297ae0133006006003375a60320066eb8c05c008c06c008c064004dd5980b18078011807800991980080080211299980a0008a6103d87a800013232323253330153371e010004266e95200033019374c00297ae01330060060033756602c0066eb8c050008c060008c058004894ccc034cdc80010008a60103d87980001533300d3371e0040022980103d87a800014c103d87b800014984d958c94ccc02ccdc3a40000022a66601c60120082930b0a99980599b874800800454ccc038c024010526161630090033232533300b3370e900000089919191919191919299980b180c80109924c64a66602866e1d2000001132323232533301b301e00213232498c94ccc068cdc3a400000226464a66603e60440042649319299980e99b87480000044c8c94ccc088c0940084c9263016001163023001301b0021533301d3370e90010008991919191919299981318148010a4c2c6eb4c09c004c09c008dd6981280098128011bad3023001301b00216301b00116302000130180031533301a3370e90010008a99980e980c0018a4c2c2c6030004601e0062c60380026038004603400260240102c602400e2c6eb8c05c004c05c008dd7180a800980a8011bad3013001301300230110013009005163009004232533300b3370e900000089919299980818098010a4c2c6eb8c044004c02400854ccc02ccdc3a400400226464a66602060260042930b1bae30110013009002163009001375a0024600a6ea80048c00cdd5000ab9a5573aaae7955cfaba05742ae881",
      hash: "a02cfaa183d42cc36bcd1e3b86fd533d62ebc86ce3f6640120c33459"
    }
  ],
  definitions: {
    ByteArray: {
      dataType: "bytes"
    },
    Int: {
      dataType: "integer"
    },
    "Option$aiken/transaction/credential/Referenced$aiken/transaction/credential/Credential": {
      title: "Optional",
      anyOf: [
        {
          title: "Some",
          description: "An optional value.",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/aiken~1transaction~1credential~1Referenced$aiken~1transaction~1credential~1Credential"
            }
          ]
        },
        {
          title: "None",
          description: "Nothing.",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    },
    "aiken/transaction/credential/Address": {
      title: "Address",
      description: "A Cardano `Address` typically holding one or two credential references.\n\n Note that legacy bootstrap addresses (a.k.a. 'Byron addresses') are\n completely excluded from Plutus contexts. Thus, from an on-chain\n perspective only exists addresses of type 00, 01, ..., 07 as detailed\n in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).",
      anyOf: [
        {
          title: "Address",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "payment_credential",
              $ref: "#/definitions/aiken~1transaction~1credential~1Credential"
            },
            {
              title: "stake_credential",
              $ref: "#/definitions/Option$aiken~1transaction~1credential~1Referenced$aiken~1transaction~1credential~1Credential"
            }
          ]
        }
      ]
    },
    "aiken/transaction/credential/Credential": {
      title: "Credential",
      description: "A general structure for representing an on-chain `Credential`.\n\n Credentials are always one of two kinds: a direct public/private key\n pair, or a script (native or Plutus).",
      anyOf: [
        {
          title: "VerificationKeyCredential",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/ByteArray"
            }
          ]
        },
        {
          title: "ScriptCredential",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    },
    "aiken/transaction/credential/Referenced$aiken/transaction/credential/Credential": {
      title: "Referenced",
      description: "Represent a type of object that can be represented either inline (by hash)\n or via a reference (i.e. a pointer to an on-chain location).\n\n This is mainly use for capturing pointers to a stake credential\n registration certificate in the case of so-called pointer addresses.",
      anyOf: [
        {
          title: "Inline",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/aiken~1transaction~1credential~1Credential"
            }
          ]
        },
        {
          title: "Pointer",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              title: "slot_number",
              $ref: "#/definitions/Int"
            },
            {
              title: "transaction_index",
              $ref: "#/definitions/Int"
            },
            {
              title: "certificate_index",
              $ref: "#/definitions/Int"
            }
          ]
        }
      ]
    },
    "marketplace/types/MarketplaceDatum": {
      title: "MarketplaceDatum",
      anyOf: [
        {
          title: "MarketplaceDatum",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "seller",
              $ref: "#/definitions/aiken~1transaction~1credential~1Address"
            },
            {
              title: "price",
              $ref: "#/definitions/Int"
            },
            {
              title: "policy",
              $ref: "#/definitions/ByteArray"
            },
            {
              title: "tokenName",
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    },
    "marketplace/types/MarketplaceRedeemer": {
      title: "MarketplaceRedeemer",
      anyOf: [
        {
          title: "Buy",
          dataType: "constructor",
          index: 0,
          fields: []
        },
        {
          title: "Close",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    }
  }
};

// src/marketplace/offchain.ts
import {
  keepRelevant,
  largestFirst,
  parseAssetUnit
} from "@meshsdk/core";
var marketplaceDatum = (sellerAddress, lovelaceFee, assetHex) => {
  const { pubKeyHash, stakeCredential } = serializeBech32Address(sellerAddress);
  const { policyId, assetName } = parseAssetUnit(assetHex);
  return conStr0([
    pubKeyAddress(pubKeyHash, stakeCredential),
    integer(lovelaceFee),
    currencySymbol(policyId),
    tokenName(assetName)
  ]);
};
var MeshMarketplaceContract = class extends MeshTxInitiator {
  ownerAddress;
  feePercentageBasisPoint;
  scriptCbor;
  constructor(inputs, ownerAddress, feePercentageBasisPoint) {
    super(inputs);
    this.ownerAddress = ownerAddress;
    this.feePercentageBasisPoint = feePercentageBasisPoint;
    const { pubKeyHash, stakeCredential } = serializeBech32Address(ownerAddress);
    this.scriptCbor = applyParamsToScript(
      plutus_default.validators[0].compiledCode,
      [
        pubKeyAddress(pubKeyHash, stakeCredential),
        integer(feePercentageBasisPoint)
      ],
      "JSON"
    );
  }
  listAsset = async (asset, price) => {
    const { utxos, walletAddress } = await this.getWalletInfoForTx();
    const assetMap = /* @__PURE__ */ new Map();
    assetMap.set(asset, "1");
    const selectedUtxos = keepRelevant(assetMap, utxos);
    const scriptAddr = v2ScriptToBech322(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    const tokenForSale = [{ unit: asset, quantity: "1" }];
    const outputDatum = marketplaceDatum(walletAddress, price, asset);
    await this.mesh.txOut(scriptAddr, tokenForSale).txOutInlineDatumValue(outputDatum, "JSON").changeAddress(walletAddress).selectUtxosFrom(selectedUtxos).complete();
    return this.mesh.txHex;
  };
  delistAsset = async (marketplaceUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    await this.mesh.spendingPlutusScriptV2().txIn(
      marketplaceUtxo.input.txHash,
      marketplaceUtxo.input.outputIndex,
      marketplaceUtxo.output.amount,
      marketplaceUtxo.output.address
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr1([])).txInScript(this.scriptCbor).changeAddress(walletAddress).requiredSignerHash(serializeBech32Address(walletAddress).pubKeyHash).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  purchaseAsset = async (marketplaceUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const inputDatum = parseDatumCbor(
      marketplaceUtxo.output.plutusData
    );
    const listingPrice = inputDatum.fields[1].int.toString();
    const selectedUtxos = largestFirst(listingPrice, utxos, true);
    const inputLovelace = marketplaceUtxo.output.amount.find(
      (a) => a.unit === "lovelace"
    ).quantity;
    const tx = this.mesh.spendingPlutusScriptV2().txIn(
      marketplaceUtxo.input.txHash,
      marketplaceUtxo.input.outputIndex,
      marketplaceUtxo.output.amount,
      marketplaceUtxo.output.address
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr0([])).txInScript(this.scriptCbor).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(selectedUtxos);
    let ownerToReceiveLovelace = inputDatum.fields[1].int * this.feePercentageBasisPoint / 1e4;
    if (this.feePercentageBasisPoint > 0 && ownerToReceiveLovelace < 1e6) {
      ownerToReceiveLovelace = 1e6;
    }
    if (ownerToReceiveLovelace > 0) {
      const ownerAddress = this.ownerAddress;
      const ownerToReceive = [
        {
          unit: "lovelace",
          quantity: Math.ceil(ownerToReceiveLovelace).toString()
        }
      ];
      tx.txOut(ownerAddress, ownerToReceive);
    }
    const sellerToReceiveLovelace = inputDatum.fields[1].int + Number(inputLovelace);
    if (sellerToReceiveLovelace > 0) {
      const sellerAddress = parsePlutusAddressObjToBech32(inputDatum.fields[0]);
      const sellerToReceive = [
        {
          unit: "lovelace",
          quantity: sellerToReceiveLovelace.toString()
        }
      ];
      tx.txOut(sellerAddress, sellerToReceive);
    }
    await tx.complete();
    return this.mesh.txHex;
  };
  relistAsset = async (marketplaceUtxo, newPrice) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const inputAsset = marketplaceUtxo.output.amount.find(
      (a) => a.unit !== "lovelace"
    ).unit;
    const tokenForSale = [{ unit: inputAsset, quantity: "1" }];
    const outputDatum = marketplaceDatum(walletAddress, newPrice, inputAsset);
    const scriptAddr = v2ScriptToBech322(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    await this.mesh.spendingPlutusScriptV2().txIn(
      marketplaceUtxo.input.txHash,
      marketplaceUtxo.input.outputIndex,
      marketplaceUtxo.output.amount,
      marketplaceUtxo.output.address
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr1([])).txInScript(this.scriptCbor).txOut(scriptAddr, tokenForSale).txOutInlineDatumValue(outputDatum, "JSON").changeAddress(walletAddress).requiredSignerHash(serializeBech32Address(walletAddress).pubKeyHash).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  getUtxoByTxHash = async (txHash) => {
    return await this._getUtxoByTxHash(this.scriptCbor, txHash);
  };
};

// src/vesting/offchain.ts
import {
  serializeBech32Address as serializeBech32Address2,
  applyParamsToScript as applyParamsToScript2,
  v2ScriptToBech32 as v2ScriptToBech323,
  parseDatumCbor as parseDatumCbor2
} from "@meshsdk/core-csl";
import {
  mConStr0 as mConStr02,
  unixTimeToEnclosingSlot,
  SLOT_CONFIG_NETWORK
} from "@meshsdk/common";

// src/vesting/aiken-workspace/plutus.json
var plutus_default2 = {
  preamble: {
    title: "meshjs/vesting",
    description: "Aiken contracts for project 'meshjs/vesting'",
    version: "0.0.0",
    plutusVersion: "v2",
    compiler: {
      name: "Aiken",
      version: "v1.0.24-alpha+982eff4"
    },
    license: "Apache-2.0"
  },
  validators: [
    {
      title: "vesting.vesting",
      datum: {
        title: "datum",
        schema: {
          $ref: "#/definitions/vesting~1types~1VestingDatum"
        }
      },
      redeemer: {
        title: "_redeemer",
        schema: {
          $ref: "#/definitions/ByteArray"
        }
      },
      compiledCode: "5901bd0100003232323232323232222325333007323232323232533300d3370e90010008a999806998029bac3004300b3003300b008375c600c6016014294454ccc034cc014dd618021805980198058041bae301130123012300b00a13322323232323232323253330173370e9001180b00109919299980c802899b8800b001003375a6038002602a004002264a66602e66e1d200230160021323253330190050031337120160026eb4c070004c054008004528180b00119b8748008c054dd5180b00099bb00033330130014c103d87a80004c0103d87980003370e900118099baa301600130160023014001300d3005300d00230113012301230123012301230123012300b3003300b008375a6006601601429405281805800980218048031180780091807180798079807980798079807980798078009119198008008019129998078008a5013232533300e3371e00400a29444cc010010004c048008dd718080009180618068008a4c26cac64a66600e66e1d2000001132323232323253330103012002149858dd7180800098080011bae300e001300e002375a6018002600a0082c600a0064600a6ea80048c00cdd5000ab9a5573aaae7955cfaba157441",
      hash: "bb213b156e2ccc52b551a4f8c3bb93ceed58500f601e2279a5eae962"
    }
  ],
  definitions: {
    ByteArray: {
      dataType: "bytes"
    },
    Int: {
      dataType: "integer"
    },
    "vesting/types/VestingDatum": {
      title: "VestingDatum",
      anyOf: [
        {
          title: "VestingDatum",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "lock_until",
              description: "POSIX time in second, e.g. 1672843961000",
              $ref: "#/definitions/Int"
            },
            {
              title: "owner",
              description: "Owner's credentials",
              $ref: "#/definitions/ByteArray"
            },
            {
              title: "beneficiary",
              description: "Beneficiary's credentials",
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    }
  }
};

// src/vesting/offchain.ts
var MeshVestingContract = class extends MeshTxInitiator {
  scriptCbor = applyParamsToScript2(plutus_default2.validators[0].compiledCode, []);
  constructor(inputs) {
    super(inputs);
  }
  depositFund = async (amount, lockUntilTimeStampMs, beneficiary) => {
    const { utxos, walletAddress } = await this.getWalletInfoForTx();
    const scriptAddr = v2ScriptToBech323(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    const { pubKeyHash: ownerPubKeyHash } = serializeBech32Address2(walletAddress);
    const { pubKeyHash: beneficiaryPubKeyHash } = serializeBech32Address2(beneficiary);
    await this.mesh.txOut(scriptAddr, amount).txOutInlineDatumValue(
      mConStr02([lockUntilTimeStampMs, ownerPubKeyHash, beneficiaryPubKeyHash])
    ).changeAddress(walletAddress).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  withdrawFund = async (vestingUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const { input: collateralInput, output: collateralOutput } = collateral;
    const scriptAddr = v2ScriptToBech323(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    const { pubKeyHash } = serializeBech32Address2(walletAddress);
    const datum = parseDatumCbor2(vestingUtxo.output.plutusData);
    const invalidBefore = unixTimeToEnclosingSlot(
      Math.min(datum.fields[0].int, Date.now() - 15e3),
      this.networkId === 0 ? SLOT_CONFIG_NETWORK.preprod : SLOT_CONFIG_NETWORK.mainnet
    ) + 1;
    await this.mesh.spendingPlutusScriptV2().txIn(
      vestingUtxo.input.txHash,
      vestingUtxo.input.outputIndex,
      vestingUtxo.output.amount,
      scriptAddr
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue("").txInScript(this.scriptCbor).txOut(walletAddress, []).txInCollateral(
      collateralInput.txHash,
      collateralInput.outputIndex,
      collateralOutput.amount,
      collateralOutput.address
    ).invalidBefore(invalidBefore).requiredSignerHash(pubKeyHash).changeAddress(walletAddress).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  getUtxoByTxHash = async (txHash) => {
    return await this._getUtxoByTxHash(this.scriptCbor, txHash);
  };
};

// src/escrow/offchain.ts
import {
  serializeBech32Address as serializeBech32Address3,
  applyParamsToScript as applyParamsToScript3,
  v2ScriptToBech32 as v2ScriptToBech324,
  parseDatumCbor as parseDatumCbor3,
  parsePlutusAddressObjToBech32 as parsePlutusAddressObjToBech322
} from "@meshsdk/core-csl";
import {
  conStr0 as conStr02,
  pubKeyAddress as pubKeyAddress2,
  value,
  mConStr1 as mConStr12,
  conStr1,
  parsePlutusValueToAssets,
  mConStr2
} from "@meshsdk/common";

// src/escrow/aiken-workspace/plutus.json
var plutus_default3 = {
  preamble: {
    title: "meshjs/escrow",
    description: "Aiken contracts for project 'meshjs/escrow'",
    version: "0.0.0",
    plutusVersion: "v2",
    compiler: {
      name: "Aiken",
      version: "v1.0.24-alpha+982eff4"
    },
    license: "Apache-2.0"
  },
  validators: [
    {
      title: "escrow.escrow",
      datum: {
        title: "datum",
        schema: {
          $ref: "#/definitions/escrow~1types~1EscrowDatum"
        }
      },
      redeemer: {
        title: "redeemer",
        schema: {
          $ref: "#/definitions/escrow~1types~1EscrowRedeemer"
        }
      },
      compiledCode: "590b40010000323232323232323232222323232323232533300c3232323232323232323232323232533301a3370e90010008991919191919191919191919191919299981499b8748000c0a00044c8c8c8c94ccc0b4cdc3a400000226464646464646464a6660706076006264a6660726078006264a66606e66e1d200430360011323232533303a3370e9002181c80089919299981e19b8748000c0ec0104c8c8c8c94ccc10cc1180084c8c8c8c8c94ccc1140084004528198189bab3036304200f330303756606c6084606c608402002866ebc020cdd2a40046608e00c6608e6e98010cc11c054cc11cdd3009a5eb80c0e401ccc0e40088c8c8cc0f00048c8dd698240011bae30460013756608a0046eb8c10c004c0e400c58dd5982200098220011821000981d0020b1820000981c0008b1813981b802181e800981a8008b1812181a1814181a0010b181d0010b181c8011bac30350023758606600266ec0dd39981080a0031ba7330200110063756606a002606a004606600260560522a66605a66e1d2002001132323232533303430370031533303400213253330323370e90021818800899191919299981b19b87480000044cc08403cc080c0ecc0d000c4c8c8c8c8c8c8c8c8c8c8c8c8c94ccc10d4ccc10c004400c52808010a5032323300100100222533304800114a026464a66608e6606404000429444cc010010004c130008dd71825000998231ba9302c00b330463752605800e97ae03302e0020043302d0020073302801f0043302701e007375660840026084004608000260800046eacc0f8004c0f8008c0f0004c0d000cc0d0008c0ac004c0e0004c0c000458c07cc0bcc08cc0bc0045858c0d4008dd618188011bac302f001337606e9ccc074040008dd39980e006801099191919299981a181b8018a99981a001099299981919b8748010c0c40044c8c94ccc0d0cdc3a4004606600226464646464646464a66607e60840042646464646464646464a66608aa66608a0022006294040085281919198008008011129998250008a511323253330493303402200213300400400114a0609c0046eb8c130004cc120dd49817007998241ba9302e00b4bd70198180010061981780100399815010804198148100059981b802119191981d0009191bad3046002375c60880026eacc10c008dd71820800981b8029981a803119191981c0009191bad3044002375c60840026eacc104008dd7181f800981a8038b1bab30400013040002303e001303e002375660780026078004607400260640022c607000260600022c603e605e6046605e0022c2c606a0046eb0c0c4008dd6181780099bb0374e6603a0200046e9ccc070034008c0ac0a0c070c0a4c074c0a4004c0bc004c09c00458c8cc004004030894ccc0b4004530103d87a800013232533302c3375e603a6054004022266e952000330300024bd70099802002000981880118178009bac302c001302c001302b001302a0013029001302800130270023758604a002604a00260480046eb0c088004c068c034c06805cc080004c060008528180c0009805180b00991191980080080191299980f0008a5eb7bdb1804cc894ccc074cdd79807180d8010028998048009bab300f301b0021001302000133002002302100123253330183370e9000180b80089bae301d3016001163008301500122323300100100322533301c00114a026464a66603666e3c00801452889980200200098100011bae301e0012232333001001003002222533301c0021001132333004004302000333223233001001005225333021001133022337606ea4010dd3001a5eb7bdb1804c8c8c8c94ccc088cdd79980a804001260103d8798000133026337606ea4020dd30038028a99981119b8f0080021323253330243370e900000089981419bb037520146052604400400a200a604400264a666046a66604c00229445280a60103d87a800013374a9000198139ba60014bd70191998008008040011112999814001080089919980200218160019991191980080080291299981680089981719bb037520086ea000d2f5bded8c0264646464a66605c66ebccc084020009300103d8798000133032337606ea4020dd40038028a99981719b8f0080021323253330303370e900000089981a19bb03752014606a605c00400a200a605c00264a66605e66e1c005200014c103d87a800013374a9000198199ba80014bd7019b80007001133032337606ea4008dd4000998030030019bad302f003375c605a0046062004605e0026eb8c09c004dd69814000981500109981319bb037520046e98004cc01801800cdd598118019bae302100230250023023001375c60360026eacc070004c07800888c8c8cc004004008894ccc06c00452889919299980d19b89375a60100046644646464a66603e66e1d20020011480004dd69812180e801180e80099299980f19b8748008004530103d87a8000132323300100100222533302400114c103d87a800013232323253330253371e014004266e95200033029375000297ae0133006006003375a604c0066eb8c090008c0a0008c098004dd59811980e001180e00099198008008051129998108008a6103d87a800013232323253330223371e010004266e95200033026374c00297ae0133006006003375660460066eb8c084008c094008c08c004dd718058011bae300c00213300400400114a0603e0046eb0c074004c8cc004004008894ccc06800452f5c0264666444646600200200644a6660400022006264660446e9ccc088dd4803198111ba9375c603e002660446ea0dd69810000a5eb80cc00c00cc090008c088004dd7180c8009bab301a00133003003301e002301c0012301830193019001223300700223375e600a6024002004446600c004466ebcc010c044c014c0440040088c0540048c050c054004894ccc03ccdc80010008a6103d87980001533300f3371e0040022980103d87a800014c103d87b800022323300100100322533301300114bd70099192999809180280109980b00119802002000899802002000980b801180a8008a4c26cac64a66601866e1d20000011323232325333013301600213232498cc0240088c8c8cc0300048c8dd6980c0011bae30160013756602a0046eb8c04c004c02400c58dd5980a000980a001180900098050040a99980619b874800800454ccc03cc028020526161533300c3370e90020008a99980798050040a4c2c2c601400e600200e464a66601666e1d20000011323232325333012301500213232498cc0200088c8c8cc02c0048c8dd6980b8011bae3015001375660280046eb8c048004c02000c58dd598098009809801180880098048010a99980599b87480080044c8c8c8c8c8c8c8c94ccc058c0640084c8c8c8c9263300e0042323233011001232375a603a0046eb8c06c004dd5980d0011bae3018001300e0053300c006232323300f001232375a60360046eb8c064004dd5980c0011bae3016001300c007163756602e002602e004602a002602a0046eacc04c004c04c008c044004c02400858c02400488c8cc00400400c894ccc03c0045261323300300330130023003301100123253330093370e9000000899191919299980818098010991924c64a66601e66e1d20000011323253330143017002132498c94ccc048cdc3a400000226464a66602e60340042649318070008b180c00098080010a99980919b87480080044c8c8c8c8c8c94ccc06cc07800852616375a603800260380046eb4c068004c068008dd6980c00098080010b18080008b180a80098068018a99980799b874800800454ccc048c03400c5261616300d00230070031630110013011002300f001300700216300700123253330083370e900000089919299980698080010a4c2c6eb8c038004c01800854ccc020cdc3a400400226464a66601a60200042930b1bae300e0013006002163006001230053754002460066ea80055cd2ab9d5573caae7d5d02ba15745",
      hash: "f0a8e4bbb7f1f75971a2c31b464b6013710ca6a6aba14cea41114362"
    }
  ],
  definitions: {
    ByteArray: {
      dataType: "bytes"
    },
    Int: {
      dataType: "integer"
    },
    "Option$aiken/transaction/credential/Referenced$aiken/transaction/credential/Credential": {
      title: "Optional",
      anyOf: [
        {
          title: "Some",
          description: "An optional value.",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/aiken~1transaction~1credential~1Referenced$aiken~1transaction~1credential~1Credential"
            }
          ]
        },
        {
          title: "None",
          description: "Nothing.",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    },
    "aiken/dict/Dict$ByteArray_Int": {
      title: "Dict",
      description: "An opaque `Dict`. The type is opaque because the module maintains some\n invariant, namely: there's only one occurrence of a given key in the dictionary.\n\n Note that the `key` parameter is a phantom-type, and only present as a\n means of documentation. Keys can be any type, yet will need to comparable\n to use functions like `insert`.\n\n See for example:\n\n ```aiken\n pub type Value =\n   Dict<PolicyId, Dict<AssetName, Int>>\n ```",
      dataType: "map",
      keys: {
        $ref: "#/definitions/ByteArray"
      },
      values: {
        $ref: "#/definitions/Int"
      }
    },
    "aiken/transaction/credential/Address": {
      title: "Address",
      description: "A Cardano `Address` typically holding one or two credential references.\n\n Note that legacy bootstrap addresses (a.k.a. 'Byron addresses') are\n completely excluded from Plutus contexts. Thus, from an on-chain\n perspective only exists addresses of type 00, 01, ..., 07 as detailed\n in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).",
      anyOf: [
        {
          title: "Address",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "payment_credential",
              $ref: "#/definitions/aiken~1transaction~1credential~1Credential"
            },
            {
              title: "stake_credential",
              $ref: "#/definitions/Option$aiken~1transaction~1credential~1Referenced$aiken~1transaction~1credential~1Credential"
            }
          ]
        }
      ]
    },
    "aiken/transaction/credential/Credential": {
      title: "Credential",
      description: "A general structure for representing an on-chain `Credential`.\n\n Credentials are always one of two kinds: a direct public/private key\n pair, or a script (native or Plutus).",
      anyOf: [
        {
          title: "VerificationKeyCredential",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/ByteArray"
            }
          ]
        },
        {
          title: "ScriptCredential",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    },
    "aiken/transaction/credential/Referenced$aiken/transaction/credential/Credential": {
      title: "Referenced",
      description: "Represent a type of object that can be represented either inline (by hash)\n or via a reference (i.e. a pointer to an on-chain location).\n\n This is mainly use for capturing pointers to a stake credential\n registration certificate in the case of so-called pointer addresses.",
      anyOf: [
        {
          title: "Inline",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/aiken~1transaction~1credential~1Credential"
            }
          ]
        },
        {
          title: "Pointer",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              title: "slot_number",
              $ref: "#/definitions/Int"
            },
            {
              title: "transaction_index",
              $ref: "#/definitions/Int"
            },
            {
              title: "certificate_index",
              $ref: "#/definitions/Int"
            }
          ]
        }
      ]
    },
    "aiken/transaction/value/Value": {
      title: "Value",
      description: "A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).\n\n This type maintain some invariants by construction; in particular, a `Value` will never contain a\n zero quantity of a particular token.",
      dataType: "map",
      keys: {
        $ref: "#/definitions/ByteArray"
      },
      values: {
        $ref: "#/definitions/aiken~1dict~1Dict$ByteArray_Int"
      }
    },
    "escrow/types/EscrowDatum": {
      title: "EscrowDatum",
      anyOf: [
        {
          title: "Initiation",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "initiator",
              $ref: "#/definitions/aiken~1transaction~1credential~1Address"
            },
            {
              title: "initiator_assets",
              $ref: "#/definitions/aiken~1transaction~1value~1Value"
            }
          ]
        },
        {
          title: "ActiveEscrow",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              title: "initiator",
              $ref: "#/definitions/aiken~1transaction~1credential~1Address"
            },
            {
              title: "initiator_assets",
              $ref: "#/definitions/aiken~1transaction~1value~1Value"
            },
            {
              title: "recipient",
              $ref: "#/definitions/aiken~1transaction~1credential~1Address"
            },
            {
              title: "recipient_assets",
              $ref: "#/definitions/aiken~1transaction~1value~1Value"
            }
          ]
        }
      ]
    },
    "escrow/types/EscrowRedeemer": {
      title: "EscrowRedeemer",
      anyOf: [
        {
          title: "RecipientDeposit",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "recipient",
              $ref: "#/definitions/aiken~1transaction~1credential~1Address"
            },
            {
              title: "recipient_assets",
              $ref: "#/definitions/aiken~1transaction~1value~1Value"
            }
          ]
        },
        {
          title: "CancelTrade",
          dataType: "constructor",
          index: 1,
          fields: []
        },
        {
          title: "CompleteTrade",
          dataType: "constructor",
          index: 2,
          fields: []
        }
      ]
    }
  }
};

// src/escrow/offchain.ts
import { mergeAssets } from "@meshsdk/core";
var initiateEscrowDatum = (walletAddress, amount) => {
  const { pubKeyHash, stakeCredential } = serializeBech32Address3(walletAddress);
  return conStr02([pubKeyAddress2(pubKeyHash, stakeCredential), value(amount)]);
};
var activeEscrowDatum = (initiationDatum, walletAddress, amount) => {
  const { pubKeyHash, stakeCredential } = serializeBech32Address3(walletAddress);
  const [initiator, initiatorAmount] = initiationDatum.fields;
  return conStr1([
    initiator,
    initiatorAmount,
    pubKeyAddress2(pubKeyHash, stakeCredential),
    value(amount)
  ]);
};
var recipientDepositRedeemer = (recipient, depositAmount) => initiateEscrowDatum(recipient, depositAmount);
var MeshEscrowContract = class extends MeshTxInitiator {
  scriptCbor = applyParamsToScript3(plutus_default3.validators[0].compiledCode, []);
  constructor(inputs) {
    super(inputs);
  }
  initiateEscrow = async (escrowAmount) => {
    const { utxos, walletAddress } = await this.getWalletInfoForTx();
    const scriptAddr = v2ScriptToBech324(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    await this.mesh.txOut(scriptAddr, escrowAmount).txOutInlineDatumValue(
      initiateEscrowDatum(walletAddress, escrowAmount),
      "JSON"
    ).changeAddress(walletAddress).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  cancelEscrow = async (escrowUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const scriptAddr = v2ScriptToBech324(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    const inputDatum = parseDatumCbor3(
      escrowUtxo.output.plutusData
    );
    if (inputDatum.constructor === 1) {
      const [
        initiatorAddressObj,
        initiatorAmount,
        recipientAddressObj,
        recipientAmount
      ] = inputDatum.fields;
      const initiatorAddress = parsePlutusAddressObjToBech322(initiatorAddressObj);
      const recipientAddress = parsePlutusAddressObjToBech322(recipientAddressObj);
      const initiatorToReceive = parsePlutusValueToAssets(initiatorAmount);
      const recipientToReceive = parsePlutusValueToAssets(recipientAmount);
      this.mesh.txOut(initiatorAddress, initiatorToReceive).txOut(recipientAddress, recipientToReceive);
    }
    await this.mesh.spendingPlutusScriptV2().txIn(
      escrowUtxo.input.txHash,
      escrowUtxo.input.outputIndex,
      escrowUtxo.output.amount,
      scriptAddr
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr12([])).txInScript(this.scriptCbor).requiredSignerHash(serializeBech32Address3(walletAddress).pubKeyHash).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  recipientDeposit = async (escrowUtxo, depositAmount) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const scriptAddr = v2ScriptToBech324(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    const inputDatum = parseDatumCbor3(
      escrowUtxo.output.plutusData
    );
    const outputDatum = activeEscrowDatum(
      inputDatum,
      walletAddress,
      depositAmount
    );
    const inputAssets = parsePlutusValueToAssets(inputDatum.fields[1]);
    const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);
    this.mesh.spendingPlutusScriptV2().txIn(
      escrowUtxo.input.txHash,
      escrowUtxo.input.outputIndex,
      escrowUtxo.output.amount,
      scriptAddr
    ).spendingReferenceTxInInlineDatumPresent().txInRedeemerValue(
      recipientDepositRedeemer(walletAddress, depositAmount),
      {
        mem: 7e6,
        steps: 3e9
      },
      "JSON"
    ).txInScript(this.scriptCbor).txOut(scriptAddr, escrowAmount).txOutInlineDatumValue(outputDatum, "JSON").changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).completeSync();
    return this.mesh.txHex;
  };
  completeEscrow = async (escrowUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const scriptAddr = v2ScriptToBech324(
      this.scriptCbor,
      void 0,
      this.networkId
    );
    const inputDatum = parseDatumCbor3(
      escrowUtxo.output.plutusData
    );
    const [
      initiatorAddressObj,
      initiatorAmount,
      recipientAddressObj,
      recipientAmount
    ] = inputDatum.fields;
    const initiatorAddress = parsePlutusAddressObjToBech322(initiatorAddressObj);
    const recipientAddress = parsePlutusAddressObjToBech322(recipientAddressObj);
    const initiatorToReceive = parsePlutusValueToAssets(recipientAmount);
    const recipientToReceive = parsePlutusValueToAssets(initiatorAmount);
    await this.mesh.spendingPlutusScriptV2().txIn(
      escrowUtxo.input.txHash,
      escrowUtxo.input.outputIndex,
      escrowUtxo.output.amount,
      scriptAddr
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr2([])).txInScript(this.scriptCbor).txOut(initiatorAddress, initiatorToReceive).txOut(recipientAddress, recipientToReceive).requiredSignerHash(serializeBech32Address3(recipientAddress).pubKeyHash).requiredSignerHash(serializeBech32Address3(initiatorAddress).pubKeyHash).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  getUtxoByTxHash = async (txHash) => {
    return await this._getUtxoByTxHash(this.scriptCbor, txHash);
  };
};

// src/giftcard/offchain.ts
import {
  v2ScriptToBech32 as v2ScriptToBech325,
  getV2ScriptHash,
  parseDatumCbor as parseDatumCbor4,
  applyParamsToScript as applyParamsToScript4
} from "@meshsdk/core-csl";
import {
  mConStr0 as mConStr03,
  builtinByteString,
  txOutRef,
  stringToHex,
  mConStr1 as mConStr13
} from "@meshsdk/common";

// src/giftcard/aiken-workspace/plutus.json
var plutus_default4 = {
  preamble: {
    title: "meshjs/giftcard",
    description: "Aiken contracts for project 'meshjs/giftcard'",
    version: "0.0.0",
    plutusVersion: "v2",
    compiler: {
      name: "Aiken",
      version: "v1.0.24-alpha+982eff4"
    },
    license: "Apache-2.0"
  },
  validators: [
    {
      title: "oneshot.gift_card",
      redeemer: {
        title: "rdmr",
        schema: {
          $ref: "#/definitions/oneshot~1Action"
        }
      },
      parameters: [
        {
          title: "token_name",
          schema: {
            $ref: "#/definitions/ByteArray"
          }
        },
        {
          title: "utxo_ref",
          schema: {
            $ref: "#/definitions/aiken~1transaction~1OutputReference"
          }
        }
      ],
      compiledCode: "5901f201000032323232323232323223222232533300932323232533300d3370e9000180600089919191919191919191919299980d980f0010991919299980d99b87480000044c94ccc070cdc3a400060360022a66603866e1c00d200213371e008030294058c8cc004004030894ccc0800045300103d87a800013232533301f3375e6048603a004034266e952000330230024bd70099802002000981200118110008a99980d99b87002480044cdc780180b8a503019014375a60360046eb8c06400458c070004c8c8c94ccc064cdc3a4004002297adef6c6013756603c602e004602e002646600200200444a666038002298103d87a8000132323232533301d3371e01e004266e95200033021374c00297ae01330060060033756603c0066eb8c070008c080008c078004c8cc004004008894ccc06c00452f5bded8c0264646464a66603866e3d221000021003133020337606ea4008dd3000998030030019bab301d003375c6036004603e004603a0026eacc068004c068004c064004c060004c05c008dd6180a80098068029bae3013001300b0011630110013011002300f001300700214984d958c94ccc024cdc3a40000022a666018600e0062930b0a99980499b874800800454ccc030c01c00c52616163007002375c0024600a6ea80048c00cdd5000ab9a5573aaae7955cfaba05742ae89",
      hash: "8a9ec1e5bc638e3de0910a52cbad0d9582cccb371eefb31f59bb3e17"
    },
    {
      title: "oneshot.redeem",
      datum: {
        title: "_d",
        schema: {
          $ref: "#/definitions/Data"
        }
      },
      redeemer: {
        title: "_r",
        schema: {
          $ref: "#/definitions/Data"
        }
      },
      parameters: [
        {
          title: "token_name",
          schema: {
            $ref: "#/definitions/ByteArray"
          }
        },
        {
          title: "policy_id",
          schema: {
            $ref: "#/definitions/ByteArray"
          }
        }
      ],
      compiledCode: "5901310100003232323232323232232232222533300932323232323232323232533301630190021323253330153370e0029000899b8f00201214a06eb4c058008dd7180a0008b180b800991919299980a19b874800800452f5bded8c026eacc064c04c008c050dd5000991980080080111299980b8008a6103d87a800013232323253330183371e026004266e9520003301c374c00297ae0133006006003375660320066eb8c05c008c06c008c064004c8cc004004008894ccc05800452f5bded8c0264646464a66602e66e3d22100002100313301b337606ea4008dd3000998030030019bab3018003375c602c004603400460300026eacc054004c054004c050004c04c004c048004c028004c03c004c02000452613656375c0026eb80048c010dd5000ab9a5573aaae7955cfaba05742ae881",
      hash: "a0922b65757e9945de58b93860c648faa5908c95d6f9d01a1d3ab3a0"
    }
  ],
  definitions: {
    ByteArray: {
      dataType: "bytes"
    },
    Data: {
      title: "Data",
      description: "Any Plutus data."
    },
    Int: {
      dataType: "integer"
    },
    "aiken/transaction/OutputReference": {
      title: "OutputReference",
      description: "An `OutputReference` is a unique reference to an output on-chain. The `output_index`\n corresponds to the position in the output list of the transaction (identified by its id)\n that produced that output",
      anyOf: [
        {
          title: "OutputReference",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "transaction_id",
              $ref: "#/definitions/aiken~1transaction~1TransactionId"
            },
            {
              title: "output_index",
              $ref: "#/definitions/Int"
            }
          ]
        }
      ]
    },
    "aiken/transaction/TransactionId": {
      title: "TransactionId",
      description: "A unique transaction identifier, as the hash of a transaction body. Note that the transaction id\n isn't a direct hash of the `Transaction` as visible on-chain. Rather, they correspond to hash\n digests of transaction body as they are serialized on the network.",
      anyOf: [
        {
          title: "TransactionId",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "hash",
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    },
    "oneshot/Action": {
      title: "Action",
      anyOf: [
        {
          title: "Mint",
          dataType: "constructor",
          index: 0,
          fields: []
        },
        {
          title: "Burn",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    }
  }
};

// src/giftcard/offchain.ts
var MeshGiftCardContract = class extends MeshTxInitiator {
  tokenNameHex = "";
  paramUtxo = { outputIndex: 0, txHash: "" };
  giftCardCbor = (tokenNameHex, utxoTxHash, utxoTxId) => applyParamsToScript4(plutus_default4.validators[0].compiledCode, [
    builtinByteString(tokenNameHex),
    txOutRef(utxoTxHash, utxoTxId)
  ]);
  redeemCbor = (tokenNameHex, policyId) => applyParamsToScript4(plutus_default4.validators[1].compiledCode, [
    tokenNameHex,
    policyId
  ]);
  constructor(inputs, tokenNameHex, paramUtxo) {
    super(inputs);
    if (tokenNameHex) {
      this.tokenNameHex = tokenNameHex;
    }
    if (paramUtxo) {
      this.paramUtxo = paramUtxo;
    }
  }
  createGiftCard = async (tokenName2, giftValue) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const tokenNameHex = stringToHex(tokenName2);
    const firstUtxo = utxos[0];
    const remainingUtxos = utxos.slice(1);
    const giftCardScript = this.giftCardCbor(
      tokenNameHex,
      firstUtxo.input.txHash,
      firstUtxo.input.outputIndex
    );
    const giftCardPolicy = getV2ScriptHash(giftCardScript);
    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);
    const redeemAddr = v2ScriptToBech325(
      redeemScript,
      void 0,
      this.networkId
    );
    await this.mesh.txIn(
      firstUtxo.input.txHash,
      firstUtxo.input.outputIndex,
      firstUtxo.output.amount,
      firstUtxo.output.address
    ).mintPlutusScriptV2().mint("1", giftCardPolicy, tokenNameHex).mintingScript(giftCardScript).mintRedeemerValue(mConStr03([])).txOut(redeemAddr, [
      ...giftValue,
      { unit: giftCardPolicy + tokenNameHex, quantity: "1" }
    ]).txOutInlineDatumValue([
      firstUtxo.input.txHash,
      firstUtxo.input.outputIndex,
      tokenNameHex
    ]).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(remainingUtxos).complete();
    this.tokenNameHex = tokenNameHex;
    this.paramUtxo = firstUtxo.input;
    return this.mesh.txHex;
  };
  redeemGiftCard = async (giftCardUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const inlineDatum = parseDatumCbor4(
      giftCardUtxo.output.plutusData
    ).list;
    const paramTxHash = inlineDatum[0].bytes;
    const paramTxId = inlineDatum[1].int;
    const tokenNameHex = inlineDatum[2].bytes;
    const giftCardScript = this.giftCardCbor(
      tokenNameHex,
      paramTxHash,
      paramTxId
    );
    const giftCardPolicy = getV2ScriptHash(giftCardScript);
    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);
    await this.mesh.spendingPlutusScriptV2().txIn(
      giftCardUtxo.input.txHash,
      giftCardUtxo.input.outputIndex,
      giftCardUtxo.output.amount,
      giftCardUtxo.output.address
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue("").txInScript(redeemScript).mintPlutusScriptV2().mint("-1", giftCardPolicy, tokenNameHex).mintingScript(giftCardScript).mintRedeemerValue(mConStr13([])).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  getUtxoByTxHash = async (txHash) => {
    const { redeemScript } = this.getScripts();
    return await this._getUtxoByTxHash(redeemScript, txHash);
  };
  getScripts = () => {
    const giftCardScript = this.giftCardCbor(
      this.tokenNameHex,
      this.paramUtxo.txHash,
      this.paramUtxo.outputIndex
    );
    const giftCardPolicy = getV2ScriptHash(giftCardScript);
    const redeemScript = this.redeemCbor(this.tokenNameHex, giftCardPolicy);
    return { giftCardScript, redeemScript };
  };
};

// src/payment-splitter/offchain.ts
import {
  resolvePlutusScriptAddress,
  resolvePaymentKeyHash,
  Transaction
} from "@meshsdk/core";
import { serializeBech32Address as serializeBech32Address4, applyParamsToScript as applyParamsToScript5 } from "@meshsdk/core-csl";
import { builtinByteString as builtinByteString2, list } from "@meshsdk/common";

// src/payment-splitter/aiken-workspace/plutus.json
var plutus_default5 = {
  preamble: {
    title: "aiken-lang/hello-world",
    description: "Aiken contracts for project 'aiken-lang/hello-world'",
    version: "0.0.0",
    plutusVersion: "v2",
    compiler: {
      name: "Aiken",
      version: "v1.0.26-alpha+075668b"
    },
    license: "Apache-2.0"
  },
  validators: [
    {
      title: "payment_splitter.payout",
      datum: {
        title: "_datum",
        schema: {
          $ref: "#/definitions/payment_splitter~1Datum"
        }
      },
      redeemer: {
        title: "_redeemer",
        schema: {
          $ref: "#/definitions/payment_splitter~1Redeemer"
        }
      },
      parameters: [
        {
          title: "scriptHashes",
          schema: {
            $ref: "#/definitions/List$ByteArray"
          }
        }
      ],
      compiledCode: "59037f010000323232323232322322322322533300832323232323232323232323253330143375e6e9cccc8c0040048894ccc06800440084ccc00c00cc8c8cc004004010894ccc07400452f5c026464a66603866ebc00801440044cc080008cc010010004c084008c07c004c070004c074004cc8c004004894ccc06400452f5c026466036002660060066600e603a004466603066ebc00400928251301b001323300100100722533301900114bd7009980d1806180c1baa300c3018375460360026600400460380020169801018000100114a0646600200200444a66603000229444c94ccc058cdc39bad301b00233005533301900414c0103d87a80001300e3301a301b0044bd70240002660060060022940c06c004c8cc004004028894ccc05c00452f5c02660306ea0c8c8c8c8c8c94ccc068cdc424000002266e04008cdc08009802005880119980119804806919baf3010301c3754602060386ea8c014c070dd5000803240004466e00004c014dd59803180e9baa3006301d375400466600266010014466ebcc03cc06cdd51807980d9baa0010054800088cdc000098021bab3005301c3754004444646600200200844a66603e0022008266006604200266004004604400246600c64a66603066e1d200230193754002298103d87a8000132330010013756603c60366ea8008894ccc074004530103d87a80001323232533301d3371e91100375c603c0062602a660426ea00052f5c026600a00a0046eb4c078008c084008c07c004c8cc004004008894ccc0700045300103d87a80001323232533301c3371e91100375c603a00626028660406e980052f5c026600a00a0046eacc074008c080008c07800520002301b301c001301900133002002301a0012253330133370e9001180a1baa00210011375a6030602a6ea800888c8cc00400400c894ccc05c00452f5c026464a66602c600a00426603400466008008002266008008002603600460320026eacc050c054008dd61809800980998098011bac3011001300d37546002601a6ea80108c040004c8cc004004020894ccc03800452f5c026601e60066601e6ea4dd71808000a5eb80cc008008c044004dd2a400029309b2b299980319b8748000c01cdd500089919299980598070010a4c2c6eb8c030004c020dd50008b299980219b8748000c014dd500089919299980498060010a4c2c6eb8c028004c018dd50008b1bac0015734aae7555cf2ab9f5740ae855d101",
      hash: "51acaf75ddb2912c78a7b6e764b6f65d2b51a73ce668165d33e7ba0d"
    }
  ],
  definitions: {
    ByteArray: {
      dataType: "bytes"
    },
    List$ByteArray: {
      dataType: "list",
      items: {
        $ref: "#/definitions/ByteArray"
      }
    },
    "payment_splitter/Datum": {
      title: "Datum",
      anyOf: [
        {
          title: "Datum",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "owner",
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    },
    "payment_splitter/Redeemer": {
      title: "Redeemer",
      anyOf: [
        {
          title: "Redeemer",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "message",
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    }
  }
};

// src/payment-splitter/offchain.ts
var MeshPaymentSplitterContract = class extends MeshTxInitiator {
  wrapPayees = (payees) => list(
    payees.map(
      (payee) => builtinByteString2(serializeBech32Address4(payee).pubKeyHash)
    )
  );
  scriptCbor = () => applyParamsToScript5(
    plutus_default5.validators[0].compiledCode,
    [this.wrapPayees(this.payees)],
    "JSON"
  );
  payees = [];
  constructor(inputs, payees) {
    super(inputs);
    if (inputs.wallet) {
      inputs.wallet.getUsedAddresses().then((addresses) => {
        this.payees = [addresses[0], ...payees];
      });
    } else {
      this.payees = payees;
      console.warn(
        "Wallet not provided. Therefore the payment address will not be added to the payees list which makes it impossible to trigger the payout."
      );
    }
  }
  sendLovelaceToSplitter = async (lovelaceAmount) => {
    if (this.wallet === null || this.wallet === void 0) {
      return;
    }
    const { walletAddress } = await this.getWalletInfoForTx();
    const script = {
      code: this.scriptCbor(),
      version: "V2"
    };
    const scriptAddress = resolvePlutusScriptAddress(script, 0);
    const hash = resolvePaymentKeyHash(walletAddress);
    const datum = {
      alternative: 0,
      fields: [hash]
    };
    const tx = new Transaction({ initiator: this.wallet }).sendLovelace(
      {
        address: scriptAddress,
        datum: { value: datum }
      },
      lovelaceAmount.toString()
    );
    const unsignedTx = await tx.build();
    const signedTx = await this.wallet.signTx(unsignedTx);
    const txHash = await this.wallet.submitTx(signedTx);
    return txHash;
  };
  triggerPayout = async () => {
    if (this.wallet === null || this.wallet === void 0) {
      return;
    }
    const { walletAddress, collateral } = await this.getWalletInfoForTx();
    const script = {
      code: this.scriptCbor(),
      version: "V2"
    };
    const scriptAddress = resolvePlutusScriptAddress(script, 0);
    const utxos = await this.fetcher?.fetchAddressUTxOs(scriptAddress) || [];
    const hash = resolvePaymentKeyHash(walletAddress);
    const datum = {
      alternative: 0,
      fields: [hash]
    };
    const redeemerData = "Hello, World!";
    const redeemer = { data: { alternative: 0, fields: [redeemerData] } };
    let tx = new Transaction({ initiator: this.wallet });
    let split = 0;
    for (const utxo of utxos) {
      const amount = utxo.output?.amount;
      if (amount) {
        let lovelace = amount.find((asset) => asset.unit === "lovelace");
        if (lovelace) {
          split += Math.floor(Number(lovelace.quantity) / this.payees.length);
        }
        tx = tx.redeemValue({
          value: utxo,
          script,
          datum,
          redeemer
        });
      }
    }
    tx = tx.setCollateral([collateral]);
    for (const payee of this.payees) {
      tx = tx.sendLovelace(payee, split.toString());
    }
    tx = tx.setRequiredSigners([walletAddress]);
    const unsignedTx = await tx.build();
    const signedTx = await this.wallet.signTx(unsignedTx, true);
    const txHash = await this.wallet.submitTx(signedTx);
    return txHash;
  };
};

// src/swap/offchain.ts
import {
  mConStr0 as mConStr04,
  mConStr1 as mConStr14,
  pubKeyAddress as pubKeyAddress3,
  value as value2,
  parsePlutusValueToAssets as parsePlutusValueToAssets2,
  conStr0 as conStr03
} from "@meshsdk/common";
import {
  applyParamsToScript as applyParamsToScript6,
  parseDatumCbor as parseDatumCbor5,
  parsePlutusAddressObjToBech32 as parsePlutusAddressObjToBech323,
  serializeBech32Address as serializeBech32Address5,
  v2ScriptToBech32 as v2ScriptToBech326
} from "@meshsdk/core-csl";

// src/swap/aiken-workspace/plutus.json
var plutus_default6 = {
  preamble: {
    title: "meshjs/swap",
    description: "Aiken contracts for project 'meshjs/swap'",
    version: "0.0.0",
    plutusVersion: "v2",
    compiler: {
      name: "Aiken",
      version: "v1.0.24-alpha+982eff4"
    },
    license: "Apache-2.0"
  },
  validators: [
    {
      title: "swap.swap",
      datum: {
        title: "datum",
        schema: {
          $ref: "#/definitions/swap~1SwapDatum"
        }
      },
      redeemer: {
        title: "redeemer",
        schema: {
          $ref: "#/definitions/swap~1SwapRedeemer"
        }
      },
      compiledCode: "59077601000032323232323232323222232325333008323232533300b3370e9001000899191919299980799b87480080084c94ccc040cdc3a4000601e0022646464646464646464646464a666038a6660380102002294040085281980299980200425eb7bdb180894ccc074cdd79807980d980a980d8010058998020009bab3015301b3015301b002100137566026603203066008664466600a00497adef6c6022533301e3375e6020603800400626600a0026eacc058c0700084004dd61802980c1806180c00a9806180c00b9bab30053018017223233300100100300222253330210021001132333004004302500333223233001001005225333026001133027337606ea4010dd3001a5eb7bdb1804c8c8c8c94ccc09ccdd799807804001260103d879800013302b337606ea4020dd30038028a99981399b8f0080021323253330293370e900000089981699bb03752014605c604e00400a200a604e00264a666050a66605600229445280a60103d87a800013374a9000198161ba60014bd70191998008008040011112999816801080089919980200218188019991191980080080291299981900089981999bb037520086ea000d2f5bded8c0264646464a66606666ebccc06c020009300103d8798000133037337606ea4020dd40038028a99981999b8f0080021323253330353370e900000089981c99bb037520146074606600400a200a606600264a66606866e1c005200014c103d87a800013374a90001981c1ba80014bd7019b80007001133037337606ea4008dd4000998030030019bad3034003375c6064004606c00460680026eb8c0b0004dd69816800981780109981599bb037520046e98004cc01801800cdd598140019bae3026002302a0023028001375c60400026eacc084004c08c008894ccc068cdc80010008a6103d87980001533301a3371e0040022980103d87a800014c103d87b8000222323300100100422533301f001100413300330210013300200230220012232323300100100222533301e00114a226464a66603a66e24dd698040011991191919299981119b8748008004520001375a604e6040004604000264a66604266e1d200200114c0103d87a8000132323300100100222533302700114c103d87a800013232323253330283371e014004266e9520003302c375000297ae0133006006003375a60520066eb8c09c008c0ac008c0a4004dd59813180f801180f80099198008008051129998120008a6103d87a800013232323253330253371e010004266e95200033029374c00297ae01330060060033756604c0066eb8c090008c0a0008c098004dd718078011bae301500213300400400114a060440046eb0c080004c8cc004004008894ccc07400452f5c0264666444646600200200644a66604600220062646604a6e9ccc094dd4803198129ba9375c60440026604a6ea0dd69811800a5eb80cc00c00cc09c008c094004dd7180e0009bab301d001330030033021002301f0012301b301c301c001533301700114a0264a6660300022944528180d00099191980080080111299980c8008a5eb804c8c94ccc060cdd79805180b1808180b00100309980e00119802002000899802002000980e801180d8009bac300530113005301100e30043010300a30100013016001300e0011632323300100100222533301500114c0103d87a80001323253330143375e600c6024004010266e952000330180024bd70099802002000980c801180b8009bac3001300d3001300d00a13232323300100100322533301600114a026464a66602a66e3c008014528899802002000980d0011bae3018001323253330123370e9000180880089bae30173010001163003300f0013002300e00d37586028602a602a602a602a602a602a602a602a601a6002601a014460280026018012602200260120042940c024004c004c01c0108c038c03c004526136563253330083370e90000008a99980598030020a4c2c2a66601066e1d20020011533300b300600414985858c01800cc8c8c94ccc024cdc3a40000022646464646464a666024602a0042646464931980500191919198068009191bad3018002375c602c0026eacc054008dd718098009980480211919198060009191bad3017002375c602a0026eacc050008dd7180900099299980819b87480000044c8c8c8c94ccc05cc0680084c8c9263253330163370e900000089919299980d980f00109924c64a66603266e1d200000113232533301e3021002132498c05400458c07c004c05c00854ccc064cdc3a40040022646464646464a666044604a0042930b1bad30230013023002375a604200260420046eb4c07c004c05c00858c05c00458c070004c05000c54ccc058cdc3a40040022a66603260280062930b0b180a00118070018b180c000980c001180b00098070030b18070028b1bab30130013013002375660220026022004601e002600e00c2c600e00a44646600200200644a66601c00229309919801801980900118019808000919299980419b87480000044c8c94ccc034c04000852616375c601c002600c0042a66601066e1d200200113232533300d3010002149858dd7180700098030010b1803000918029baa001230033754002ae6955ceaab9e5573eae815d0aba21",
      hash: "3f1869e426f5350c595ffd8ca4a6fba8186947ae0cd6c136fe23054a"
    }
  ],
  definitions: {
    ByteArray: {
      dataType: "bytes"
    },
    Int: {
      dataType: "integer"
    },
    "Option$aiken/transaction/credential/Referenced$aiken/transaction/credential/Credential": {
      title: "Optional",
      anyOf: [
        {
          title: "Some",
          description: "An optional value.",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/aiken~1transaction~1credential~1Referenced$aiken~1transaction~1credential~1Credential"
            }
          ]
        },
        {
          title: "None",
          description: "Nothing.",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    },
    "aiken/dict/Dict$ByteArray_Int": {
      title: "Dict",
      description: "An opaque `Dict`. The type is opaque because the module maintains some\n invariant, namely: there's only one occurrence of a given key in the dictionary.\n\n Note that the `key` parameter is a phantom-type, and only present as a\n means of documentation. Keys can be any type, yet will need to comparable\n to use functions like `insert`.\n\n See for example:\n\n ```aiken\n pub type Value =\n   Dict<PolicyId, Dict<AssetName, Int>>\n ```",
      dataType: "map",
      keys: {
        $ref: "#/definitions/ByteArray"
      },
      values: {
        $ref: "#/definitions/Int"
      }
    },
    "aiken/transaction/credential/Address": {
      title: "Address",
      description: "A Cardano `Address` typically holding one or two credential references.\n\n Note that legacy bootstrap addresses (a.k.a. 'Byron addresses') are\n completely excluded from Plutus contexts. Thus, from an on-chain\n perspective only exists addresses of type 00, 01, ..., 07 as detailed\n in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).",
      anyOf: [
        {
          title: "Address",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "payment_credential",
              $ref: "#/definitions/aiken~1transaction~1credential~1Credential"
            },
            {
              title: "stake_credential",
              $ref: "#/definitions/Option$aiken~1transaction~1credential~1Referenced$aiken~1transaction~1credential~1Credential"
            }
          ]
        }
      ]
    },
    "aiken/transaction/credential/Credential": {
      title: "Credential",
      description: "A general structure for representing an on-chain `Credential`.\n\n Credentials are always one of two kinds: a direct public/private key\n pair, or a script (native or Plutus).",
      anyOf: [
        {
          title: "VerificationKeyCredential",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/ByteArray"
            }
          ]
        },
        {
          title: "ScriptCredential",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              $ref: "#/definitions/ByteArray"
            }
          ]
        }
      ]
    },
    "aiken/transaction/credential/Referenced$aiken/transaction/credential/Credential": {
      title: "Referenced",
      description: "Represent a type of object that can be represented either inline (by hash)\n or via a reference (i.e. a pointer to an on-chain location).\n\n This is mainly use for capturing pointers to a stake credential\n registration certificate in the case of so-called pointer addresses.",
      anyOf: [
        {
          title: "Inline",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              $ref: "#/definitions/aiken~1transaction~1credential~1Credential"
            }
          ]
        },
        {
          title: "Pointer",
          dataType: "constructor",
          index: 1,
          fields: [
            {
              title: "slot_number",
              $ref: "#/definitions/Int"
            },
            {
              title: "transaction_index",
              $ref: "#/definitions/Int"
            },
            {
              title: "certificate_index",
              $ref: "#/definitions/Int"
            }
          ]
        }
      ]
    },
    "aiken/transaction/value/Value": {
      title: "Value",
      description: "A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).\n\n This type maintain some invariants by construction; in particular, a `Value` will never contain a\n zero quantity of a particular token.",
      dataType: "map",
      keys: {
        $ref: "#/definitions/ByteArray"
      },
      values: {
        $ref: "#/definitions/aiken~1dict~1Dict$ByteArray_Int"
      }
    },
    "swap/SwapDatum": {
      title: "SwapDatum",
      anyOf: [
        {
          title: "SwapDatum",
          dataType: "constructor",
          index: 0,
          fields: [
            {
              title: "initiator",
              $ref: "#/definitions/aiken~1transaction~1credential~1Address"
            },
            {
              title: "to_provide",
              $ref: "#/definitions/aiken~1transaction~1value~1Value"
            },
            {
              title: "to_receive",
              $ref: "#/definitions/aiken~1transaction~1value~1Value"
            }
          ]
        }
      ]
    },
    "swap/SwapRedeemer": {
      title: "SwapRedeemer",
      anyOf: [
        {
          title: "Cancel",
          dataType: "constructor",
          index: 0,
          fields: []
        },
        {
          title: "Swap",
          dataType: "constructor",
          index: 1,
          fields: []
        }
      ]
    }
  }
};

// src/swap/offchain.ts
var MeshSwapContract = class extends MeshTxInitiator {
  scriptCbor = applyParamsToScript6(plutus_default6.validators[0].compiledCode, []);
  scriptAddress;
  constructor(inputs) {
    super(inputs);
    this.scriptAddress = v2ScriptToBech326(
      this.scriptCbor,
      void 0,
      this.networkId
    );
  }
  initiateSwap = async (toProvide, toReceive) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const { pubKeyHash, stakeCredential } = serializeBech32Address5(walletAddress);
    const swapDatum = conStr03([
      pubKeyAddress3(pubKeyHash, stakeCredential),
      value2(toProvide),
      value2(toReceive)
    ]);
    await this.mesh.txOut(this.scriptAddress, toProvide).txOutInlineDatumValue(swapDatum, "JSON").changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  acceptSwap = async (swapUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const inlineDatum = parseDatumCbor5(swapUtxo.output.plutusData);
    const initiatorAddress = parsePlutusAddressObjToBech323(
      inlineDatum.fields[0]
    );
    const initiatorToReceive = inlineDatum.fields[2];
    await this.mesh.spendingPlutusScriptV2().txIn(
      swapUtxo.input.txHash,
      swapUtxo.input.outputIndex,
      swapUtxo.output.amount,
      swapUtxo.output.address
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr14([])).txInScript(this.scriptCbor).txOut(initiatorAddress, parsePlutusValueToAssets2(initiatorToReceive)).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  cancelSwap = async (swapUtxo) => {
    const { utxos, walletAddress, collateral } = await this.getWalletInfoForTx();
    const inlineDatum = parseDatumCbor5(swapUtxo.output.plutusData);
    const initiatorAddress = parsePlutusAddressObjToBech323(
      inlineDatum.fields[0]
    );
    await this.mesh.spendingPlutusScriptV2().txIn(
      swapUtxo.input.txHash,
      swapUtxo.input.outputIndex,
      swapUtxo.output.amount,
      swapUtxo.output.address
    ).spendingReferenceTxInInlineDatumPresent().spendingReferenceTxInRedeemerValue(mConStr04([])).txInScript(this.scriptCbor).changeAddress(walletAddress).txInCollateral(
      collateral.input.txHash,
      collateral.input.outputIndex,
      collateral.output.amount,
      collateral.output.address
    ).requiredSignerHash(serializeBech32Address5(initiatorAddress).pubKeyHash).selectUtxosFrom(utxos).complete();
    return this.mesh.txHex;
  };
  getUtxoByTxHash = async (txHash) => {
    return await this._getUtxoByTxHash(this.scriptCbor, txHash);
  };
};
export {
  MeshEscrowContract,
  MeshGiftCardContract,
  MeshMarketplaceContract,
  MeshPaymentSplitterContract,
  MeshSwapContract,
  MeshVestingContract,
  activeEscrowDatum,
  initiateEscrowDatum,
  marketplaceDatum,
  recipientDepositRedeemer
};
